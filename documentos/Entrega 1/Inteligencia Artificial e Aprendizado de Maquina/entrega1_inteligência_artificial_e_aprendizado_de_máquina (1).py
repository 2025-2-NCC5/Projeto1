# -*- coding: utf-8 -*-
"""entrega1_Inteligência_Artificial_e_Aprendizado_de_Máquina.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y_bdo11O1rmGzEFgMC-J7I02cz19dwaG
"""

# Commented out IPython magic to ensure Python compatibility.
# Carregando bibliotecas/Pacotes
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

import statsmodels.api as sm
import statsmodels.formula.api as smf
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score, roc_curve, classification_report,\
                            accuracy_score, confusion_matrix, auc

#Lendo o conjunto de dados da tabela ‘Order Semicolon’
#mostrando os 5 primeiros registros com a função head()

semicolon = pd.read_csv('/content/Order_semicolon.csv', sep=';')
semicolon.head()

#Aqui uma função foi criada para calcular a distribuição da frequência,
#ou seja, contando a quantidade de vezes que as categorias de
#PENDING;DISPATCHED;PLACED;CONFIRMED;CONCLUDED;CANCELED
#estão aparecendo dentro da planilha e em seguida, fazendo a contagem percentual desse valor.


def freq(x: pd.Series, plot=False):
    contagem = x.value_counts()
    percentual = round((x.value_counts() / x.shape[0]) * 100, 3)
    res = pd.DataFrame({'n': contagem, 'perc': percentual})
    if plot:
        sns.countplot(x)
        plt.show()
    return res
print(freq(semicolon["status"]))

#obter a porcentagem do total de cada categoria (a função freq mostra isso também)
(semicolon.status.value_counts() / semicolon.shape[0]) * 100

#Criar um boxplot com as categorias do status
freq(semicolon.status, plot=True)

##Descreve toda a coluna ‘status’, nisso temos a contagem total dos registros da coluna(count),unique (a contagem de variação dentro dessa coluna),
#top(que é a categoria que aparece com mais frequência) e o total de vezes que essa categoria aparece
semicolon.status.describe()

#Nesse outro trecho,
#um box plot é criado para ver como o status dos pedidos se distribui em relação a coluna de canal de vendas (salesChannel).

sns.boxplot(x='status', y='salesChannel', data=semicolon)
plt.title('Distribuição de status')
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

#Contagem de quantos pedidos de cada categoria de status cada cliente fez.
status_counts = semicolon.groupby(['customer', 'status']).size().reset_index(name='count')

print(status_counts)

#Demonstrando essa relação de distribuição de status e cliente por meio do boxplot

plt.figure(figsize=(12,6))
sns.boxplot(x='status', y='count', data=status_counts)
plt.title('Distribuição da quantidade de status por cliente')
plt.xlabel('Status')
plt.ylabel('Quantidade por cliente')
plt.show()

# Transformando em categoria: is_canceled, facilitando a identificação
#Quando o pedido está cancelado, essa coluna recebe valor 1.
semicolon['salesChannel'] = semicolon['salesChannel'].astype('category')

semicolon['is_canceled'] = (semicolon['status'] == 'CANCELED').astype(int)

#criando o modelo de regressão, ou seja, criando o modelo para identificar se o pedido vai ser ou não cancelado.
#Adicionando outras colunas
#tempo de preparo (preparationTime)
#tempo de retirada (takeOutTimeInSeconds)
#canal de vendas (salesChannel)

modelo = smf.glm(
    formula='is_canceled ~ preparationTime + takeOutTimeInSeconds + C(salesChannel)',
    data=semicolon,
    family=sm.families.Binomial()
).fit()

#os coeficientes do modelo mostram se cada variável aumenta ou diminui a chance de cancelamento.
print(modelo.summary())

#o print está mostrando as razões de chance da regressão logistica, ou seja, o print mostra a chance de cancelamento.
#caso o cancelamento seja >1, tem maior que chance de acontecer
# <1 tem menos chance de acontecer.
print(np.exp(modelo.params[1:]))

#aqui estamos transformando os valores em porcentagem , e se o valor for positivo tem maior chance de ser cancelado
#ou se for negativo, tem menor chance
# se for zero, as chances de ser cancelado nao alteram.
(np.exp(modelo.params[1:]) - 1) * 100

#neste momento estamos criando um modelo de regressao logistica, usando o sklearn, transformando os dados
#em categorias de zero e um

model = LogisticRegression(penalty=None, solver='newton-cg')
baseline_df = semicolon[['status', 'orderType', 'salesChannel', 'engineType']].dropna()
#y é que desejamos prever
y = baseline_df.status
# alvo variável, vendo se foi ounao cancelado
#o dummies está transformando as categorias em colunas binarias, zero ou  um
X = pd.get_dummies(baseline_df[['orderType', 'salesChannel', 'engineType']], drop_first=True).astype(int)

print(X)

model.fit(X, y)

LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=100,
                   multi_class='warn', n_jobs=None, penalty=None,
                   random_state=None, solver='newton-cg', tol=0.0001, verbose=0,
                   warm_start=False)

#resultado dos coeficientes que o modelo de regressão aprendeu,
#Valores positivos- aumentam a chance de um pedido cair naquela categoria.
#Valores negativos− diminuem a chance e numeros proximos de zero não influenciam

print(model.coef_)

# Previsão
#as colunas representam as classes de status
yhat = model.predict_proba(X)
yhat

#Selecionando apenas a probabilidade da classe de índice 1(segunda classe no modelo)
yhat = yhat[:, 1]
yhat

#tabela cruzada (matriz de confusão, mas com formato de DataFrame)
confusion_matrix(y, model.predict(X)) # matriz de confusão

pd.crosstab(y, model.predict(X))

ac = accuracy_score(y, model.predict(X))
ac

#mostrando as metricas de cada classe
print(classification_report(y, model.predict(X)))

#y deve ser 0/1
y = (baseline_df.status == 'CANCELED').astype(int)

# Previsões
yhat_prob = model.predict_proba(X)[:, 1]

from sklearn.metrics import roc_auc_score
print('AUC: %0.2f' % roc_auc_score(y, yhat_prob))

print('AUC: %0.2f' % roc_auc_score(y, yhat))

def plot_roc_curve(y_true, y_score, figsize=(10,6)):
    fpr, tpr, _ = roc_curve(y_true, y_score)
    plt.figure(figsize=figsize)
    auc_value = roc_auc_score(y_true, y_score)
    plt.plot(fpr, tpr, color='orange', label='ROC curve (area = %0.2f)' % auc_value)
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.show()

plot_roc_curve(y, yhat)